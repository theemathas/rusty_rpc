use std::io;
use std::sync::Arc;

use async_trait::async_trait;
use futures::{Sink, Stream};
use serde::de::DeserializeOwned;
use serde::Serialize;
use tokio::sync::Mutex;

use crate::messages::{ClientMessage, MethodArgs, MethodId, ServerMessage, ServiceId};
use crate::ServiceCollection;

/// For any given service trait `MyService` which came from the
/// `interface_file!` macro in the `rusty_rpc_macro` crate, the type `dyn
/// MyService` (unsized naked dyn trait) implements [RustyRpcServiceClient].
///
/// Users should not manually implement this trait.
///
/// For some reason the Send + Sync + 'static bound is needed for
/// `tokio::spawn`.
pub trait RustyRpcServiceClient {
    /// A proxy that client uses to reference such a service. This proxy type
    /// will implement the service trait (e.g. MyService).
    ///
    /// When the ServiceRef for a certain service is closed on the client
    /// side, the associated resources, are dropped on the server side. If the
    /// type `T` is an implementation of a certain service, then `Response<T>`
    /// will implement the corresponding service trait.
    type ServiceProxy: RustyRpcServiceProxy;
}

/// Used with [RustyRpcServiceClient]. Something that implements
/// `RustyRpcServiceProxy<dyn T>` will also always be generated so it implements
/// `T`. This type is a proxy that deallocates server-side resources when the
/// `.close()` method is called. If it is dropped without being closed, it will
/// panic.
#[allow(drop_bounds)]
pub trait RustyRpcServiceProxy: Drop {
    #[doc(hidden)]
    fn from_service_id(
        service_id: ServiceId,
        stream_sink: Arc<Mutex<dyn ClientStreamSink>>,
    ) -> Self;
}

/// Alias for `Stream + Sink`, so we can use it as a dyn trait. Represents the
/// communication channel endpoint on the client's side
pub trait ClientStreamSink:
    Stream<Item = io::Result<ServerMessage>> + Sink<ClientMessage, Error = io::Error> + Send + Unpin
{
}
impl<
        T: Stream<Item = io::Result<ServerMessage>>
            + Sink<ClientMessage, Error = io::Error>
            + Send
            + Unpin,
    > ClientStreamSink for T
{
}

/// Used for type safety in the `new()` method of [crate::messages::ServiceRef].
/// Like [RustyRpcServiceServer], it is also automatically implemented for user
/// types.
pub trait RustyRpcServiceServerWithKnownClientType: RustyRpcServiceServer {
    #[doc(hidden)]
    type ClientType: RustyRpcServiceClient + ?Sized;
}

/// This trait will be automatically implemented by any user type marked with
/// the `#[service_server_impl]` attribute in the `rusty_rpc_macro` crate. Users
/// should not manually implement this trait.
///
/// Client-side access to services (via [RustyRpcServiceClient::ServiceRef]) CANNOT
/// use this trait.
///
/// For some reason the Send + Sync + 'static bound is needed for
/// `tokio::spawn`.
#[async_trait]
pub trait RustyRpcServiceServer: Send + Sync + 'static {
    #[doc(hidden)]
    async fn parse_and_call_method_locally(
        &mut self,
        method_id: MethodId,
        method_args: MethodArgs,
        service_collection: &mut ServiceCollection,
    ) -> io::Result<ServerMessage>;
}

/// This trait will be automatically implemented by struct types generated by
/// the `interface_file!` macro in the `rusty_rpc_macro` crate. Users should not
/// manually implement this trait.
pub trait RustyRpcStruct: Serialize + DeserializeOwned {}
/// i32 is treated like a struct in this library.
impl RustyRpcStruct for i32 {}
